using MediatR;
using StructureMap.Attributes;
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Threading.Tasks;
using VerticalSlice.POC.Core;
using VerticalSlice.POC.DataAccess;
using VerticalSlice.POC.DataAccess.Entities;
using VerticalSlice.POC.Services.IServices;

namespace VerticalSlice.POC.Services
{
    /// <summary>
    /// Abstract handler responsible to provide support for inherited handlers
    /// </summary>
    /// <typeparam name="TRequest"></typeparam>
    /// <typeparam name="TResponse"></typeparam>
    public abstract class BaseHandler<TRequest, TResponse> : IRequestHandler<TRequest, TResponse>
             where TRequest : BaseRequest<TResponse>
             where TResponse : BaseResponse
    {
        private VerticalSliceDbContext _dbContext;
        private IConfigsService configsService;
        private CurrentUserModel _currentLoggedInUser;

        [SetterProperty]
        public VerticalSliceDbContext DbContext
        {
            set
            {
                if (_dbContext != null)
                    throw new CoreException("DbContext has already beeen initialized!");
                else
                    _dbContext = value;
            }
        }

        [SetterProperty]
        public IConfigsService ConfigsService
        {
            set { configsService = value; }
        }

        public CurrentUserModel CurrentUser
        {
            set { _currentLoggedInUser = value; }
        }

        /// <summary>
        /// Use this when you want to do CRUD on the database using Entity Framework
        /// </summary>
        protected VerticalSliceDbContext _ef => _dbContext;

        /// <summary>
        /// Use this when you want to do CRUD on the database using Dapper
        /// </summary>
        protected IDbConnection _connection => new SqlConnection(configsService.ConnectionString);

        /// <summary>
        /// Use this whenever you need to get configs from the AppSettings section in the appSettings.json configuration
        /// </summary>
        protected IConfigsService _configsService => configsService;

        /// <summary>
        /// Use this when you need info on the logged in user which called the API. It contains its Id and e-mail address
        /// </summary>
        protected CurrentUserModel _currentUser => _currentLoggedInUser;

        /// <summary>
        /// DO NOT INVOKE IN HANDLERS. It's auto-invoked when a handler finishes it's job.
        /// </summary>
        /// <returns></returns>
        public async Task SaveChanges()
        {
            await _dbContext.SaveChangesAsync();
            _connection?.Close();
        }

        /// <summary>
        /// Updates an already existing entity
        /// </summary>
        /// <param name="entity">The entity which needs to be updated in the database</param>
        protected void Update(BaseEntity entity)
        {
            if (entity.Id.Equals(Guid.Empty))
                _ef.Add(entity);
            else
                _ef.Update(entity);
        }

        /// <summary>
        /// Adds an entity to the database, and returns its Id
        /// </summary>
        /// <param name="entity">The entity to add in the database</param>
        /// <returns>The Id generated by the database for the added entity</returns>
        protected Guid Add(BaseEntity entity)
        {
            return _ef.Add(entity).Entity.Id;
        }

        /// <summary>
        /// HARD deletes the given entity from the database.
        /// </summary>
        /// <param name="entity">The entity to be HARD deleted</param>
        protected void Remove(BaseEntity entity)
        {
            _ef.Remove(entity);
        }

        /// <summary>
        /// Returns an entity of type <typeparamref name="EntityType"/> which matches the given Id parameter
        /// </summary>
        /// <typeparam name="EntityType"></typeparam>
        /// <param name="id">Id of the entity to retrive</param>
        /// <returns>Found entity of type <typeparamref name="EntityType"/> if exists, otherwise null</returns>
        protected async Task<EntityType> GetById<EntityType>(Guid id)
            where EntityType : BaseEntity
        {
            return await _ef.FindAsync<EntityType>(id);
        }

        public abstract Task<TResponse> Handle(TRequest request, CancellationToken cancellationToken);
       
    }

    public class CurrentUserModel
    {
        public Guid Id { get; private set; }
        public string Email { get; private set; }

        public CurrentUserModel(Guid id, string email)
        {
            Id = id;
            Email = email;
        }
    }
}
